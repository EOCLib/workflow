name: 服务部署 (BWSM 动态配置-v2)

on:
  workflow_call:
    inputs:
      image-name:
        description: "The name of the docker image (e.g., backend_achievement)"
        required: true
        type: string

jobs:
  deploy:
    runs-on: self-hosted

    # 1. 注入 BWSM 访问令牌
    env:
      BWS_ACCESS_TOKEN: ${{ secrets.BWS_ACCESS_TOKEN }}

    steps:
      - name: 拉取代码
        uses: actions/checkout@v4
# 2. 从 Bitwarden Secrets Manager 拉取所有配置
      - name: ⚙️ 从 Bitwarden Secrets Manager 拉取密钥
        shell: bash
        run: |
          echo "=== 正在从 Bitwarden 拉取所有配置... ==="
          
          # --- UUID 列表 ---
          DEPLOY_TOKEN_UUID="1e270108-0ff6-40f6-8a55-b3950123d77e"
          DEPLOY_URLS_UUID="232126b5-ba94-42a6-9483-b395012740aa"
          REG_DOMAIN_UUID="b4a93650-a363-4214-b445-b39501270fad"
          REG_PASS_UUID="c8fe427e-b0ca-41ec-9976-b395012452fa"
          
          # 拉取所有值
          echo "正在获取 DEPLOY_TOKEN..."
          DEPLOY_TOKEN_VALUE=$(bws secret get $DEPLOY_TOKEN_UUID | jq -r .value)
          echo "::add-mask::$DEPLOY_TOKEN_VALUE"
          
          echo "正在获取 DEPLOY_URLS..."
          DEPLOY_URLS_VALUE=$(bws secret get $DEPLOY_URLS_UUID | jq -r .value)
          echo "::add-mask::$DEPLOY_URLS_VALUE"

          echo "正在获取 REGISTRY_DOMAIN..."
          REGISTRY_DOMAIN_VALUE=$(bws secret get $REG_DOMAIN_UUID | jq -r .value)
          echo "::add-mask::$REGISTRY_DOMAIN_VALUE"

          echo "正在获取 REGISTRY_PASSWORD..."
          REGISTRY_PASSWORD_VALUE=$(bws secret get $REG_PASS_UUID | jq -r .value)
          echo "::add-mask::$REGISTRY_PASSWORD_VALUE"

          # 健壮性检查 (保持不变)
          if [ -z "$DEPLOY_TOKEN_VALUE" ] || [ -z "$DEPLOY_URLS_VALUE" ] || \
             [ -z "$REGISTRY_DOMAIN_VALUE" ] || [ -z "$REGISTRY_PASSWORD_VALUE" ]; then
            echo "::error:: 无法从 Bitwarden 获取一个或多个密钥。"
            exit 1
          fi

          # ----------------------------------------------------------------
          # 变化点：使用 EOF 多行安全语法注入 GITHUB_ENV
          # ----------------------------------------------------------------
          echo "=== 密钥拉取成功，正在注入到 GITHUB_ENV... ==="
          
          echo "DEPLOY_TOKEN<<EOF" >> $GITHUB_ENV
          echo "$DEPLOY_TOKEN_VALUE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          echo "DEPLOY_URLS<<EOF" >> $GITHUB_ENV
          echo "$DEPLOY_URLS_VALUE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          echo "REGISTRY_DOMAIN<<EOF" >> $GITHUB_ENV
          echo "$REGISTRY_DOMAIN_VALUE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          echo "REGISTRY_PASSWORD<<EOF" >> $GITHUB_ENV
          echo "$REGISTRY_PASSWORD_VALUE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
      # 3. 动态登录 Docker 仓库
      - name: 登录 Docker 仓库
        shell: bash
        run: |
          echo "正在登录 $REGISTRY_DOMAIN ..."
          echo "$REGISTRY_PASSWORD" | docker login $REGISTRY_DOMAIN -u catvote --password-stdin
          echo "登录成功。"

      # 4. 动态构建和推送 Docker 镜像
      - name: 构建和推送 Docker 镜像
        shell: bash
        run: |
          IMAGE_TAG="$REGISTRY_DOMAIN/catvote/${{ inputs.image-name }}:latest"
          echo "开始构建镜像: $IMAGE_TAG"
          docker build -t $IMAGE_TAG .
          echo "=== 镜像构建完成 ==="
          docker images $IMAGE_TAG --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
          echo "开始推送镜像: $IMAGE_TAG"
          docker push $IMAGE_TAG
          echo "镜像推送完成: $IMAGE_TAG"

      # ----------------------------------------------------------------
      # 变化点：这里的 bash 脚本已更新，用于解析 "名称|URL" 格式
      # ----------------------------------------------------------------
      - name: 触发服务器更新 (动态名称版)
        shell: bash
        run: |
          echo "开始触发服务器更新..."
          echo "从 BWSM 拉取的原始列表: $DEPLOY_URLS"
          
          # 1. 设置主分隔符为 逗号(,)，将字符串 $DEPLOY_URLS 读入数组
          IFS=',' read -r -a SERVER_PAIRS <<< "$DEPLOY_URLS"
          
          if [ ${#SERVER_PAIRS[@]} -eq 0 ]; then
              echo "::warning:: 未在 BWSM 中找到任何 DEPLOY_URLS，跳过更新步骤。"
              exit 0
          fi

          # 2. 循环遍历数组 (e.g., "服务器1|http://...")
          for PAIR in "${SERVER_PAIRS[@]}"
          do
            # 3. 设置次分隔符为 管道符(|)，将 PAIR 分割为 NAME 和 URL
            IFS='|' read -r SERVER_NAME SERVER_URL <<< "$PAIR"
            
            # 4. 清理可能存在的空格，增加容错性
            TRIMMED_NAME=$(echo "$SERVER_NAME" | xargs)
            TRIMMED_URL=$(echo "$SERVER_URL" | xargs)

            # 5. 确保我们同时获得了名称和 URL
            if [ -n "$TRIMMED_NAME" ] && [ -n "$TRIMMED_URL" ]; then
              
              # 6. 【实现您的需求】使用服务器名称打印日志
              echo "正在向 $TRIMMED_NAME ($TRIMMED_URL) 发送更新请求..."
              
              # 7. 执行 curl
              curl -fsS -H "Authorization: Bearer $DEPLOY_TOKEN" "$TRIMMED_URL"
              
              echo "请求 $TRIMMED_NAME 已发送。"
            else
              echo "::warning:: 发现格式不正确的条目 '$PAIR'，已跳过。 (应为 '名称|URL' 格式)"
            fi
          done
          
          echo "所有服务器更新触发完成"